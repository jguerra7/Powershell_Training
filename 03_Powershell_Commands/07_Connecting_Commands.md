# The pipeline: connecting commands
Previously, you learned that running commands in PowerShell is the same as running commands in any other shell: You type a command name, give it parameters, and hit Enter. What makes PowerShell special isn’t the way it runs commands, but the way it allows multiple commands to be connected to each other in powerful, one-line sequences.

## Connecting one command to another: less work for you
PowerShell connects commands to each other by using a pipeline. The pipeline provides a way for one command to pass, or pipe, its output to another command, allowing that second command to have something to work with.

You’ve already seen this in action in commands such as Dir | More. You’re piping the output of the Dir command into the More command; the More command takes that directory listing and displays it one page at a time. PowerShell takes that same piping concept and extends it to greater effect.

PowerShell’s use of a pipeline may seem similar at first to the way UNIX and Linux shells work. Don’t be fooled, though. As you’ll come to realize over the next examples, PowerShell’s pipeline implementation is much richer and more modern.

Run a simple command. Here are a few suggestions:
```
Get-Process (or gps; this should work on macOS and Linux too)
Get-Service (or gsv; only on Windows)
Get-EventLog Security -newest 100 (only on Windows)
```
We picked these commands because they’re easy, straightforward commands. We used parentheses to give you the aliases for Get-Process and Get-Service. For Get-EventLog, which works only on Windows, we specified its mandatory parameter as well as the -newest parameter (which shows you that the command won’t take too long to execute).

> Try it Now

Go ahead and choose the commands you want to work with. We use Get-Process for the following examples; you can stick with one of the three we’ve listed, or switch between them to see the differences in the results.
```
What do you see? When we run Get-Process, a table with several columns of information appears on the screen

```
![image](https://user-images.githubusercontent.com/47218880/61734103-dd157e00-ad46-11e9-9468-edf381e60ba1.png)

It’s great to have that information on the screen, but that isn’t all you might want to do with the information. For example, if you want to make charts and graphs of memory and CPU utilization, you might want to export the information into a comma-separated values (CSV) file that could be read into an application such as Microsoft Excel.

# CSV

Exporting to a file is where the pipeline and a second command come in handy:
```powershell
Get-Process | Export-CSV procs.csv
```
Similar to piping Dir to More, we’ve piped our processes to Export-CSV. That second cmdlet has a mandatory positional parameter that we’ve used to specify the output filename. Because Export-CSV is a native PowerShell cmdlet, it knows how to translate the table usually generated by Get-Process into a standard CSV file.


Go ahead and open the file in Windows Notepad to see the results, as shown in figure below:

Notepad procs.csv

![image](https://user-images.githubusercontent.com/47218880/61734359-6dec5980-ad47-11e9-9758-e3e6193ebe3b.png)

![image](https://user-images.githubusercontent.com/47218880/61734673-01258f00-ad48-11e9-87ad-bcb164949962.png)

The first line of the file is a comment, preceded by a # character, and it identifies the kind of information that’s included in the file. In the figure above, it’s System .Diagnostics .Process, which is the under-the-hood name that Windows uses to identify the information related to a running process. The second line contains column headings, and the subsequent lines list the information for the various processes running on the computer.


You can pipe the output of almost any Get- cmdlet to Export-CSV and get excellent results. You may also notice that the CSV file contains a great deal more information than what’s typically shown on the screen. That’s deliberate. The shell knows it can’t possibly fit all of that information on the screen, so it uses a configuration file, supplied by Microsoft, to select the most important information for onscreen display. In later chapters, we’ll show you how to override that configuration to display whatever you want.


Once the information is saved into a CSV file, you can easily email it to colleagues and ask them to view it from within PowerShell. To do this, they’d import the file:

```powershell

Import-CSV procs.csv
```
The shell would read in the CSV file and display the process information. It wouldn’t be based on live information, but it would be a snapshot from the exact point in time that you created the CSV file.

## XML

What if CSV files aren’t what you need? PowerShell also has an Export-CliXML cmdlet, which creates a generic command-line interface (CLI) Extensible Markup Language (XML) file. CliXML is unique to PowerShell, but any program capable of understanding XML can read it. You’ll also have a matching Import-CliXML cmdlet. Both the import and export cmdlets (such as Import-CSV and Export-CSV) expect a filename as a mandatory parameter.

### Try it Now

Try exporting such things as services, processes, or event log entries to a CliXML file. Make sure you can reimport the file, and try opening the resulting file in Notepad and Internet Explorer to see how each application displays the information.

Does PowerShell include any other import or export commands? You could find out by using the Get-Command cmdlet and specifying a -verb parameter with either Import or Export.

### Try it Now

See if PowerShell comes with any other import or export cmdlets. You may want to repeat this check after you load new commands into the shell—something you’ll do in the next lessons.

## File Comparison

Both CSV and CliXML files can be useful for persisting snapshots of information, sharing those snapshots with others, and reviewing those snapshots at a later time. In fact, Compare-Object has a great way of using them. It has an alias, Diff, which we’ll use.

First, run help diff and read the help for this cmdlet. We want you to pay attention to three parameters in particular: -ReferenceObject, -DifferenceObject, and -Property.

Diff is designed to take two sets of information and compare them to each other. For example, imagine that you run Get-Process on two computers that are sitting side by side. The computer that’s configured exactly the way you want is on the left and is the reference computer. The computer on the right might be the same, or it might be somewhat different; it’s the difference computer. After running the command on each, you’re staring at two tables of information, and your job is to figure out whether any differences exist between the two.

Because these are processes that you’re looking at, you’re always going to see differences in things like CPU and memory utilization numbers, so we’ll ignore those columns. In fact, focus on the Name column, because we want to see whether the difference computer contains any additional, or any fewer, processes than the reference computer. It might take you a while to compare all of the process names from both tables, but you don’t have to—that’s exactly what Diff will do for you.

Let’s say you sit down at the reference computer and run this:

```powershell
Get-Process | Export-CliXML reference.xml
```
We prefer using CliXML rather than CSV for comparisons like this, because CliXML can hold more information than a flat CSV file. You then transport that XML file to the difference computer, and run this command:
```powershell
Diff -reference (Import-CliXML reference.xml) -difference (Get-Process) -property Name
```
Because the previous step is a bit tricky, we’ll explain what’s happening:

As in math, parentheses in PowerShell control the order of execution. In the previous example, they force Import-CliXML and Get-Process to run before Diff runs. The output from Import-CliXML is fed to the -reference parameter, and the output from Get-Process is fed to the -difference parameter. The parameter names are -referenceObject and -differenceObject; keep in mind that you can abbreviate parameter names by typing enough of their names for the shell to be able to figure out which one you want. In this case, -reference and -difference are more than enough to uniquely identify these parameters. We probably could have shortened them even further to something like -ref and -diff, and the command would still have worked.

Rather than comparing the two complete tables, Diff focuses on the Name, because we gave it the -property parameter. If we hadn’t, it would think that every process is different because the values of columns such as VM, CPU, and PM are always going to be different.

The result is a table telling you what’s different. Every process that’s in the reference set, but not in the difference set, will have a <= indicator (which indicates that the process is present only on the left side). If a process is on the difference computer but not the reference computer, it’ll have a => indicator instead. Processes that match across both sets aren’t included in the Diff output.


## Piping to a file

Whenever you have nicely formatted output—for example, the tables generated by Get-Service or Get-Process—you may want to preserve that in a file or even on paper. Normally, cmdlet output is directed to the screen, which PowerShell refers to as the host, but you can change where that output goes. We’ve already showed you one way to do so:
```powershell
Dir > DirectoryList.txt
```
The > character is a shortcut added to PowerShell to provide syntactic compatibility with the older Cmd.exe shell. In reality, when you run that command, PowerShell does the following under the hood:
```powershell
Dir | Out-File DirectoryList.txt
```
You can run that same command on your own, instead of using the > syntax. Why would you do so? Because Out-File also provides additional parameters that let you specify alternative character encodings (such as UTF-8 or Unicode), append content to an existing file, and so forth. By default, the files created by Out-File are 80 columns wide, which means sometimes PowerShell might alter command output to fit within 80 characters. That alteration might make the file’s contents appear different than when you run the same command on the screen. Read Out-File’s help file and see if you can spot a parameter that would let you change the output file width to something other than 80 characters.

# HTML

Want to produce HTML reports? Well, this isn’t available on other operating systems (at the time of writing this book). But it’s easy on Windows: Pipe your command to ConvertTo-HTML. This command produces well-formed, generic HTML that displays in any web browser. It’s plain looking, but you can reference a Cascading Style Sheets (CSS) file to specify more-attractive formatting if desired. Notice that this command doesn’t require a filename:
```powershell
Get-Service | ConvertTo-HTML
```
> Try it Now
```
Make sure that you run that command yourself—we want you to see what it does before you proceed.
```
In the PowerShell world, the verb Export implies that you’re taking data, converting it to some other format, and saving that other format in some kind of storage, such as a file. The verb ConvertTo implies only a portion of that process: the conversion to a different format, but not saving it into a file. When you ran the preceding command, you got a screen full of HTML, which probably wasn’t what you wanted. Stop for a second: Can you think of how you’d get that HTML into a text file on disk?

> Try it Now
```
If you can think of a way, go ahead and try it before you read on.
```
> This command does the trick:
```powershell
Get-Service | ConvertTo-HTML | Out-File services.html
```
See how connecting more and more commands allows you to have increasingly powerful command lines? Each command handles a single step in the process, and the entire command line as a whole accomplishes a useful task.

PowerShell ships with other ConvertTo- cmdlets, including ConvertTo-CSV and ConvertTo-XML. As with ConvertTo-HTML, these don’t create a file on disk; they translate command output into CSV or XML, respectively. You could pipe that converted output to Out-File to then save it to disk, although it would be shorter to use Export-CSV or Export-CliXML, because those do both the conversion and the saving.





































